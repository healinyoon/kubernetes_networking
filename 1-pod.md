# 목적

쿠버네티스 클러스터에서 동작하는 여러 네트워크 layer에 대해 파헤친다. 각 layer 별로 어떤 역할을 하는지 쪼개서 이해한다면 문제가 발생했을 때, 전체 layer를 살펴보며 문제의 원인을 파악할 수 있을 것이다.

# Pods

Pod는 쿠버네티스의 가장 기본이 되는 단위이다. Pod는 적어도 한 개 이상의 컨테이너를 구성하며, 내부적으로 동일한 host와 네트워크 스택을 공유, volume과 같은 리소스들을 공유한다.

"네트워크 스택을 공유한다"의 의미는 Pod 안의 모든 컨테이너가 localhost를 통해 접근 가능함을 의미한다. 예를들어 80 포트를 사용하고 있는 nginx 컨테이너가 있으면 scrapyd를 실행하고 있는 다른 컨테이너에서 http://localhost:80으로 nginx 컨테이너에 접근 가능하다. 어떻게 동작하는 것일까?

## 컨테이너 한 개를 실행했을 때 어떤 일이 벌어지는지 관찰해보자.

![](/images/1-pod/pod1.jpg)

위에서부터 아래로 살펴보면, **physical network interface**인 **eth0**을 볼 수 있다. eth0에는 **bridge**인 **docker0**이 달려있다. 그리고 docker0에는 다시 **virtual network interface**인 **veth0**이 연결되어 있다. docker0과 veth0은 예시에서 `172.17.0.0/24`처럼 같은 네트워크로 묶여 있는 것을 볼 수 있다. 해당 네트워크에서 docker0은 172.17.0.1로 설정되어 있고, veth0(172.17.0.2)의 default gateway 역할을 하고 있다. docker 컨테이너를 실행할 때 네크워크 namespace가 적절히 설정되어 컨테이너 내부에서는 veth0만 보이게 된다. 그리고 컨테이너는 veth0 -> docker0 -> eth0을 통해 외부와 통신을 하게 된다.

## 두 번째 컨테이너를 실행시켜보자.

![](/images/1-pod/pod2.jpg)

위의 그림에서 볼 수 있듯이, 두 번째 컨테이너는 veth1이라는 새로운 virtual network interface를 가진다. 그리고 이것은 docker0 bridge에 연결된다. 새로 생성된 veth1에는 `172.17.0.3`이 할당되었고, 이는 첫 번째 컨테이너, bridge와 동일한 논리 네트워크 대역이다. 따라서 서로의 IP를 어떻게든 알 수만 있다면(발견할 수 있다면) bridge를 통해 서로 통신할 수 있다.

> (참고) 컨테이너와 bridge 간의 연결은 **linkef virtual ethernet device pair**로 연결된다. 컨테이너 내부에서는 container network namespace를 외부에서는 root network namespace를 가지고 있다.

하지만 이것만으로 Pod의 네트워크 스택을 공유해주진 않는다. 다행히 namespace는 매우 유연한 구조로 되어 있다. docker에서 컨테이너를 실행할 때 새로운 virtual network interface를 생성하는 대신, **기존에 생성된 virtual network interface**를 이용할 수 있다.

## 기존에 생성된 virtual network interface 이용하는 기술

![](/images/1-pod/pod3.jpg)

두 번째 컨테이너가 새로운 veth1을 가지는 것이 아니라 veth0을 공유하는 것을 볼 수 있다. 이를 통해 알 수 있는 사실은 다음과 같다.
1) 두 컨테이너 모두 외부에서 172.17.0.2로 접근 가능하다.  
2) 두 컨테이너는 내부적으로 localhost를 통해 port로 통신 가능하다. 즉 port 중복은 불가능하다.
    이것은 제약사항이기도 하지만 여타 다른 multiple process와 동일한 제약이다. 이런 방법을 통해 두 개의 process가 고립된 환경에서 서로 결합되지 않는 이점을 가지는 동시에 동일한 네트워크 환경을 공유할 수 있게 된다.

## 쿠버네티스의 pause 컨테이너가 제공하는 network interface 기능을 살펴보자.

![](/images/1-pod/pod4.jpg)

쿠버네티스는 virtual network interface를 컨테이너를 통해 구현한다. 이 특별한 컨테이너는 각 Pod마다 존재하며, 다른 컨테이너들에게 network interface를 제공하는 역할만을 담당한다. 만약 pod가 실행되는 worker node에 들어가서 `docker ps | grep pause` 명령어를 입력하면, 적어도 한 개 이상의 `pause`로 실행되고 있는 컨테이너를 확인할 수 있다. pause 컨테이너는 쿠버네티스가 `SIGTERM` 명령을 내리기 전까지는 아무 것도 하지 않고 sleep 상태로 존재한다. 하는 일은 거의 없지만 이 pause 컨테이너가 서로 다른 컨테이너 간 통신, 외부와의 통신을 담당하는 pod의 핵심이라고 볼 수 있다. 

# Pod 네트워크

지금까지의 기술도 멋지지만, 한 개 pod 내에서 여러 개의 컨테이커들이 서로 대화할 수 있다고 해서 시스템을 구현하지는 못한다. 이러한 이유로 다음 포스트에서 이야기할 service는 쿠버네티스의 핵심 디자인 철학이며 서로 다른 pod가 동일한 서버에 있든, 다른 서버에 위치하든 상관없이 통신할 수 있게 해준다. 

이번에는 네트워크 라우팅, 라우트을 조금 살펴보자. 쿠버네티스 클러스터는 한 개 이상의 노드를 가지고 있다. **노드**란 **물리적이든 가상이든 컨테이너 런타임을 탑재하고 있고, 쿠버네티스 컴포넌트들이 들어 있는 host 시스템을 말한다.** 간다한 두 개의 노드를 갖는 클러스터는 다음 그림과 같을 것이다.

![](/images/1-pod/pod5.jpg)

위의 예시에서는 private network 대역을 `10.100.0.0/24`로 설정하였고, 라우터를 10.100.0.1, 다른 두개의 노드를 각각 10.100.0.2와 10.100.0.3으로 설정하였다. 이 설정대로라면 각 노드들은 다른 노드에 eth0을 통해 통신할 수 있다.

그런데 앞서 보았다시피 pod들은 해당 private network 대역과 맞지 않다. pod 들은 bridge를 통해 전혀 다른 네트워크 대역을 가지고 있고, 그것들은 가상으로 생성되어 있으며, 특정 노드에만 존재한다. 이를 명확하게 설명하기 위해 위의 그림에 pod를 추가해보자.

## Pod 네트워크가 추가하면

![](/images/1-pod/pod6.jpg)

먼저 default gateway가 `10.100.0.1`로 설정되어 있다.

### 왼쪽 node
왼쪽의 host의 인터페이스 eth0(`10.100.0.2`)은 docker0(`172.17.0.1`)과 연결되어있다. docker0 bridge와 맞물린 veth0(`172.17.0.2)는 pause 컨테이너를 통해 생성되었고 나머지 컨테이너 들이 모두 네트워크 스택을 공유하고 있다.

① eth0 인터페이스에 172.17.0.2의 목적지를 가진 packet은 ② host 내의 **지역 라우팅 rule**에 의해 docker0 bridge에 전달되고, ③ 그것은 다시 veth0으로 전달된다. 여기까지는 매우 순조롭다. 이제 우리가 이 host에 `172.17.0.2` pod가 있다는 것을 알면, 해당 주소로 `10.100.0.2`의 target을 라우팅 rule을 설정하면 된다. 그렇다면 최종적으로 `172.17.0.2`으로 가게 될 것이다.

### 오른쪽 node
오른쪽 host의 인터페이스 eth0(`10.100.0.3`)은 왼쪽과 마찬가지로 default gateway를 사용한다. 그리고 동일하게 docker0 bridge(`172.17.0.1`)가 eth0과 연결되어 있다. 문제가 발생하는 지점이다. docker0 bridge는 어쩌면 왼쪽 host의 bridge와 다른 주소로 설정될 수도 있다. 여기서는 최악의 상황을 일부러 고려하고 있으나, 이러한 일은 꽤 쉽게 일어난다. 만약 docker를 그냥 설치하고 바로 사용한다면, 이러한 문제 상황으로 설정되어 있을 확률이 높다. 어찌되었든 근본적인 문제는 **한 쪽 노드에서 다른 노드의 bridge에 어떠한 내부 주소를 할당받았는지 모른다**는 것이다. 즉 우리는 어디로 packet을 보내야할 지 모르게 된다. 새로운 구조가 필요한 것을 알 수 있다.

## 쿠버네티스의 해결 방안
쿠버네티스는 2가지 방법으로 이 문제를 해결한다. 
1. 가장 먼저 쿠버네티스는 각 노드의 bridge가 서로 겹치지 않도록 전체를 아우르는 주소 대역을 할당한다. 그리고 난 뒤 해당 대역 내에서 각 bridge에 실제 주소를 할당한다.
2. Gateway(`10.100.0.1`)에 어떤 packet이 어떤 bridge로 가야하는지에 대한 라우팅 테이블을 설정한다. 어떤 노드의 eth0을 통해 해당 bridge에 접근 가능한지 말이다. 이렇게 **virtual network interface** + **bridge** + **라우팅 rule**의 조합을 **Overlay Network** 라고 한다. 왜냐하면 overlay network를 이용하여 pod들이 정보를 주고 받기 때문이다.
